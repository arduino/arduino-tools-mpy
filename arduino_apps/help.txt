enable_apps():
  Enable support for Arduino MicroPython Apps.

disable_apps():
  Disable support for Arduino MicroPython Apps.

create_app('{app name}', set_default = False, hidden = False):
  Creates a app with the given name. No special characters allowed. Spaces will be converted to '_'
  Setting the app as default will make it run at boot/reset.
  Making the app hidden will prevent its listing.
  Useful for launchers and other management utilities not to be messed with.

delete_app([force_confirm = 'n']):
  Deletes the app with the given name.
  If force_confirm is set to 'Y' no confirmation will be required to delete the whole tree.

hide_app('{app name}'):
  Will set the app to hidden.

unhide_app('{app name}'):
  Will set the app to visible.

list_apps(return_list = False, include_hidden = False): [REPL/interactive]
  Interactively list apps in REPL unless return_list is True.
  Hidden apps are excluded by default.

get_apps_list(include_hidden = False)
  Returns an Array of apps and some basic info:
  Path, name, default, hidden.
  Hidden apps are excluded by default.

default_app():
  Displays the app currently set as default (if any)

default_app('{app name}', fall_back = None):
  If app name is '' (empty string), no default will be set.
  If fall_back is set (and is a valid app), at the next reset/boot that will become the default app to run.

export_app('{app name}'):
  Creates a .tar archive of the app with the given name if valid.
  The archive file will be named appending a timestamp to the app name.
  The archive will be saved in '/amp_exports/filename.tar'

import_app('{archive path}', force_overwrite = False):
  Expands the .tar archive into a app folder.
  Requires confirmation if app exists unless force_overwrite is True.

delete_folder('{folder path}', [force_confirm = 'n']):
  Will attempt to delete the folder and all its content recursively.
  If force_confirm is set to True it will not ask for confirmation at each file/folder.

list_directory('{folder path}'):
  [helper] Will recursively list through the path specified, indicationg if the item is a directory (d:) or a file (f:)

fs_root():
  [helper] Will change the current directory to root ('/')

read_file('{file path}'):
 Will read the content of the file and output it to REPL
